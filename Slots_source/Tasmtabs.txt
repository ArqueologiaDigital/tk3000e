TASM TABLES  Version 2.8                                      Page 1


6502 INSTRUCTIONS AND ADDRESSING MODES

The acceptable 6502 opcode mnemonics for TASM are as follows:

         ADC  AND  ASL  BCC  BCS  BEQ  BNE  BMI  BPL  BVC  BVS  BIT
         BRK  CLC  CLD  CLI  CLV  CMP  CPX  CPY  DEC  DEX  DEY  EOR
         INC  INX  INY  JMP  JSR  LDA  LDX  LDY  LSR  NOP  ORA  PHA
         PHP  PLA  PLP  ROL  ROR  RTI  RTS  SBC  SEC  SED  SEI  STA
         STX  STY  TAX  TAY  TSX  TXA  TXS  TYA

TASM  also  supports the following instructions that are part of the
Rockwell  R65C02  and  R65C00/21  microprocessor  instruction  sets.
Those  that  are  marked  as  set A are applicable to the R65C02 and
those marked as set B are  applicable  to  the  R65C00/21  (A+B  for
both):

        Mnemonic        Description                Address Mode  Set
        ---------------------------------------------------------------
        ADC             Add with carry             (IND)         A
        AND             And memory with A          (IND)         A
        BIT             Test memory bits with A    ABS,X         A
        BIT             Test memory bits with A    ZP,X          A
        BIT             Test memory bits with A    IMM           A
        CMP             Compare memory with A      (IND)         A
        DEC             Decrement A                A             A
        EOR             Exclusive OR memory with A (IND)         A
        INC             Increment A                A             A
        JMP             Jump                       (ABS,X)       A
        LDA             Load A with memory         (IND)         A
        ORA             OR A with memory           (IND)         A
        SBC             Subtract memory form A     (IND)         A
        STA             Store A in memory          (IND)         A
        STZ             Store zero                 ABS           A
        STZ             Store zero                 ABS,X         A
        STZ             Store zero                 ZP            A
        STZ             Store zero                 ZP,X          A
        TRB             Test and reset memory bit  ABS           A
        TRB             Test and reset memory bit  ZP            A
        TSB             Test and set memory bit    ABS           A
        TSB             Test and set memory bit    ZP            A

        BRA             Branch Always              REL           A+B

        BBR0            Branch on Bit 0 Reset      ZP,REL        A+B
        BBR1            Branch on Bit 1 Reset      ZP,REL        A+B
        BBR2            Branch on Bit 2 Reset      ZP,REL        A+B
        BBR3            Branch on Bit 3 Reset      ZP,REL        A+B
        BBR4            Branch on Bit 4 Reset      ZP,REL        A+B
        BBR5            Branch on Bit 5 Reset      ZP,REL        A+B
        BBR6            Branch on Bit 6 Reset      ZP,REL        A+B
        BBR7            Branch on Bit 7 Reset      ZP,REL        A+B

        BBS0            Branch on Bit 0 Set        ZP,REL        A+B
        BBS1            Branch on Bit 1 Set        ZP,REL        A+B
        BBS2            Branch on Bit 2 Set        ZP,REL        A+B
TASM TABLES  Version 2.8                                      Page 2

        BBS3            Branch on Bit 3 Set        ZP,REL        A+B
        BBS4            Branch on Bit 4 Set        ZP,REL        A+B
        BBS5            Branch on Bit 5 Set        ZP,REL        A+B
        BBS6            Branch on Bit 6 Set        ZP,REL        A+B
        BBS7            Branch on Bit 7 Set        ZP,REL        A+B

        MUL             Multiply                   Implied       B

        PHX             Push Index X               Implied       A+B
        PHY             Push Index Y               Implied       A+B
        PLX             Pull Index X               Implied       A+B
        PLY             Pull Index Y               Implied       A+B

        RMB0            Reset Memory Bit 0         ZP            A+B
        RMB1            Reset Memory Bit 1         ZP            A+B
        RMB2            Reset Memory Bit 2         ZP            A+B
        RMB3            Reset Memory Bit 3         ZP            A+B
        RMB4            Reset Memory Bit 4         ZP            A+B
        RMB5            Reset Memory Bit 5         ZP            A+B
        RMB6            Reset Memory Bit 6         ZP            A+B
        RMB7            Reset Memory Bit 7         ZP            A+B

        SMB0            Set   Memory Bit 0         ZP            A+B
        SMB1            Set   Memory Bit 1         ZP            A+B
        SMB2            Set   Memory Bit 2         ZP            A+B
        SMB3            Set   Memory Bit 3         ZP            A+B
        SMB4            Set   Memory Bit 4         ZP            A+B
        SMB5            Set   Memory Bit 5         ZP            A+B
        SMB6            Set   Memory Bit 6         ZP            A+B
        SMB7            Set   Memory Bit 7         ZP            A+B

Addressing  modes  are denoted as follows:

        ABS               Absolute
        ZP                Zero Page
        ABS,X             Absolute X
        ZP,X              Zero Page X
        ABS,Y             Absolute Y
        ZP,Y              Zero Page Y
        A                 Accumulator
        (IND,X)           Indirect X
        (IND),Y           Indirect Y
        (IND)             Indirect
        #IMM              Immediate
        REL               Relative (Branch instructions only)
        ZP,REL            Zero Page, Relative
        Implied           Implied

Note  that Zero Page addressing can not be explicitly requested.  It
is used if the value of the operand is  representable  in  a  single
byte for the applicable statements.

The '-x' command line option can be  used  to  enable  the  extended
instructions.  A  '-x'  with  no  digit  following  will  enable the
standard set plus both extended sets.  The 6502 version of TASM uses
three bits in the instruction class  mask  to  determine  whether  a
TASM TABLES  Version 2.8                                      Page 3

given  instruction  is enabled or not.  Bit 0 enables the basic set,
bit 1 enables set A (R65C02) and bit 2 enables  set  B  (R65C00/21).
The following table shows various options:


        Class Mask        Enabled Instructions
                        BASIC   R65C02  R65C00/21
        --------------------------------------------
        1               yes     no      no
        2               no      yes     no
        3               yes     yes     no
        4               no      no      yes
        5               yes     no      yes
        6               no      yes     yes
        7               yes     yes     yes

Thus,  to enable the basic set plus the R65C02 instructions,  invoke
the '-x3' command line option.

See manufacturer's data for  a  more  complete  description  of  the
meaning    of     the     mnemonics    and     addressing     modes.
TASM TABLES  Version 2.8                                      Page 4

8048 INSTRUCTIONS AND ADDRESSING MODES

The following list shows the acceptable opcode mnemonics  and  their
corresponding  operand  formats for the 8048 version of TASM.  Where
'Rn' is seen,  R0 through R7  may  be  substituted.  Other  symbolic
fields are as follows:

        SYMBOLIC            DESCRIPTION
        -----------------------------------------------
        <addr8>             Absolute address (8 bits)
        <addr11>            Absolute address (11 bits)
        <immed>             Immediate data

Any valid TASM expression can appear in the  place  of  any  of  the
above symbolics.

The lines that are marked with an (8041),  (8022),  or (8021) on the
far  right are extended instructions that are available only if a -x
option has  been  invoked  on  the  command  line.  The  classes  of
instructions  (and their bit assignment in the class mask) are shown
below:

        BIT     PROCESSOR
        -------------------------------
        0       8X48, 8035, 8039, 8049
        1       8X41A
        2       8022
        3       8021

Thus, to enable the basic 8048 set plus the 8022 set, a -x5 could be
used on the command line.

Note that some of the base instructions should be disabled  for  the
8041, 8022, and 8021, but are not.

OPCODE  OPERANDS        DESCRIPTION
-------------------------------------------------------------------
ADD     A,Rn            Add Register to Acc
ADD     A,@R0           Add Indirect RAM to Acc
ADD     A,@R1           Add Indirect RAM to Acc
ADD     A,#<immed>      Add Immediate data to Acc

ADDC    A,Rn            Add Register to Acc with carry
ADDC    A,@R0           Add Indirect RAM to Acc with carry
ADDC    A,@R1           Add Indirect RAM to Acc with carry
ADDC    A,#<immed>      Add Immediate data to Acc with carry

ANL     A,Rn            AND Register to Acc
ANL     A,@R0           AND Indirect RAM to Acc
ANL     A,@R1           AND Indirect RAM to Acc
ANL     A,#<immed>      AND Immediate data to Acc
ANL     BUS,#<immed>    AND Immediate data to BUS
ANL     P1,#<immed>     AND Immediate data to port P1
ANL     P2,#<immed>     AND Immediate data to port P2

ANLD    P4,A            AND Acc to Expander port P4
TASM TABLES  Version 2.8                                      Page 5

ANLD    P5,A            AND Acc to Expander port P5
ANLD    P6,A            AND Acc to Expander port P6
ANLD    P7,A            AND Acc to Expander port P7

CALL    <addr11>        Call subroutine

CLR     A               Clear Acc
CLR     C               Clear Carry
CLR     F0              Clear Flag 0
CLR     F1              Clear Flag 1

CPL     A               Complement Acc
CPL     C               Complement Carry
CPL     F0              Complement Flag F0
CPL     F1              Complement Flag F1

DA      A               Decimal adjust Acc

DEC     A               Decrement Acc
DEC     Rn              Decrement Register

DIS     I               Disable Interrupts
DIS     TCNTI           Disable Timer/Counter Interrupt

DJNZ    Rn,<addr8>      Decrement Register and Jump if nonzero

EN      DMA             Enable DMA                           (8041)
EN      FLAGS           Enable Flags                         (8041)
EN      I               Enable External Interrupt
EN      TCNTI           Enable Timer/Counter Interrupt
ENT0    CLK             Enable Clock Output

IN      A,DBB           Input Data Bus to Acc                (8041)
IN      A,P0            Input Port 0 to Acc                  (8021)
IN      A,P1            Input Port 1 to Acc
IN      A,P2            Input Port 2 to Acc

INC     A               Increment Acc
INC     Rn              Increment Register
INC     @R0             Increment Indirect RAM
INC     @R1             Increment Indirect RAM

INS     A,BUS           Strobed Input of Bus to Acc

JB0     <addr8>         Jump if Acc bit 0 is set
JB1     <addr8>         Jump if Acc bit 1 is set
JB2     <addr8>         Jump if Acc bit 2 is set
JB3     <addr8>         Jump if Acc bit 3 is set
JB4     <addr8>         Jump if Acc bit 4 is set
JB5     <addr8>         Jump if Acc bit 5 is set
JB6     <addr8>         Jump if Acc bit 6 is set
JB7     <addr8>         Jump if Acc bit 7 is set
JMP     <addr11>        Jump
JC      <addr8>         Jump if Carry is set
JF0     <addr8>         Jump if Flag F0 is set
JF1     <addr8>         Jump if Flag F1 is set
TASM TABLES  Version 2.8                                      Page 6

JNC     <addr8>         Jump if Carry is clear
JNI     <addr8>         Jump if Interrupt input is clear
JNIBF   <addr8>         Jump if IBF is clear                 (8041)
JNT0    <addr8>         Jump if T0 is clear
JNT1    <addr8>         Jump if T1 is clear
JNZ     <addr8>         Jump if Acc is not zero
JOBF    <addr8>         Jump if OBF is set                   (8041)
JTF     <addr8>         Jump if Timer Flag is set
JT0     <addr8>         Jump if T0 pin is high
JT1     <addr8>         Jump if T1 pin is high
JZ      <addr8>         Jump if Acc is zero
JMPP    @A              Jump Indirect (current page)

MOV     A,PSW           Move PSW to Acc
MOV     A,Rn            Move Register to Acc
MOV     A,T             Move Timer/Counter to Acc
MOV     A,@R0           Move Indirect RAM to Acc
MOV     A,@R1           Move Indirect RAM to Acc
MOV     A,#<immed>      Move Immediate data to Acc
MOV     PSW,A           Move Acc to PSW
MOV     Rn,A            Move Acc to Register
MOV     Rn,#<immed>     Move Immediate data to Register
MOV     STS,A           Move Acc to STS                      (8041)
MOV     T,A             Move Acc to Timer/Counter
MOV     @R0,A           Move Acc to Indirect RAM
MOV     @R1,A           Move Acc to Indirect RAM
MOV     @R0,#<immed>    Move Immediate data to Indirect RAM
MOV     @R1,#<immed>    Move Immediate data to Indirect RAM

MOVD    A,P4            Move half-byte Port 4 to Acc (lower nibble)
MOVD    A,P5            Move half-byte Port 5 to Acc (lower nibble)
MOVD    A,P6            Move half-byte Port 6 to Acc (lower nibble)
MOVD    A,P7            Move half-byte Port 7 to Acc (lower nibble)
MOVD    P4,A            Move lower nibble of Acc to Port 4
MOVD    P5,A            Move lower nibble of Acc to Port 5
MOVD    P6,A            Move lower nibble of Acc to Port 6
MOVD    P7,A            Move lower nibble of Acc to Port 7

MOVP    A,@A            Move Indirect Program data to Acc
MOVP3   A,@A            Move Indirect Program data to Acc (page 3)

MOVX    A,@R0           Move Indirect External RAM to Acc
MOVX    A,@R1           Move Indirect External RAM to Acc
MOVX    @R0,A           Move Acc to Indirect External RAM
MOVX    @R1,A           Move Acc to Indirect External RAM

NOP                     No operation

ORL     A,Rn            OR Register to Acc
ORL     A,@R0           OR Indirect RAM to Acc
ORL     A,@R1           OR Indirect RAM to Acc
ORL     A,#<immed>      OR Immediate data to Acc
ORL     BUS,#<immed>    OR Immediate data to BUS
ORL     P1,#<immed>     OR Immediate data to port P1
ORL     P2,#<immed>     OR Immediate data to port P2

TASM TABLES  Version 2.8                                      Page 7

ORLD    P4,A            OR lower nibble of Acc with P4
ORLD    P5,A            OR lower nibble of Acc with P5
ORLD    P6,A            OR lower nibble of Acc with P6
ORLD    P7,A            OR lower nibble of Acc with P7

OUTL    BUS,A           Output Acc to Bus
OUT     DBB,A           Output Acc to DBB                    (8041)
OUTL    P0,A            Output Acc to Port P0                (8021)
OUTL    P1,A            Output Acc to Port P1
OUTL    P2,A            Output Acc to Port P2

RAD                     Move A/D Converter to Acc            (8022)

RET                     Return from subroutine
RETI                    Return from Interrupt w/o PSW restore(8022)
RETR                    Return from Interrupt w/  PSW restore

RL      A               Rotate Acc Left
RLC     A               Rotate Acc Left through Carry
RR      A               Rotate Acc Right
RRC     A               Rotate Acc Right through Carry

SEL     AN0             Select Analog Input 0                (8022)
SEL     AN1             Select Analog Input 1                (8022)
SEL     MB0             Select Memory Bank 0
SEL     MB1             Select Memory Bank 1
SEL     RB0             Select Register Bank 0
SEL     RB1             Select Register Bank 1

STOP    TCNT            Stop Timer/Counter
STRT    CNT             Start Counter
STRT    T               Start Timer

SWAP    A               Swap nibbles of Acc

XCH     A,Rn            Exchange Register with Acc
XCH     A,@R0           Exchange Indirect RAM with Acc
XCH     A,@R1           Exchange Indirect RAM with Acc

XCHD    A,@R0           Exchange lower nibble of Indirect RAM w/ Acc
XCHD    A,@R1           Exchange lower nibble of Indirect RAM w/ Acc

XRL     A,Rn            Exclusive OR Register to Acc
XRL     A,@R0           Exclusive OR Indirect RAM to Acc
XRL     A,@R1           Exclusive OR Indirect RAM to Acc
XRL     A,#<immed>      Exclusive OR Immediate data to Acc

See manufacturer's data for  a  more  complete  description  of  the
meaning    of     the     mnemonics    and     addressing     modes.
TASM TABLES  Version 2.8                                      Page 8

8051 INSTRUCTIONS AND ADDRESSING MODES

The following list shows the acceptable opcode mnemonics  and  their
corresponding  operand  formats for the 8051 version of TASM.  Where
'Rn' is seen,  R0 through R7  may  be  substituted.  Other  symbolic
fields are as follows:

        SYMBOLIC            DESCRIPTION
        -----------------------------------------------
        <addr11>            Absolute address (11 bits)
        <addr16>            Absolute address (16 bits)
        <bit>               Bit address
        <immed>             Immediate data
        <direct>            Direct RAM address
        <rel>               Relative address

Any valid TASM expression can appear in the  place  of  any  of  the
above symbolics.

OPCODE  OPERAND             DESCRIPTION
--------------------------------------------------------------------
ACALL   <addr11>            Absolute Call
ADD     A,Rn                Add Register to Acc
ADD     A,@R0               Add Indirect RAM to Acc
ADD     A,@R1               Add Indirect RAM to Acc
ADD     A,#<immed>          Add Immediate data to Acc
ADD     A,<direct>          Add Direct RAM to Acc
ADDC    A,Rn                Add Register to Acc with carry
ADDC    A,@R0               Add Indirect RAM to Acc with carry
ADDC    A,@R1               Add Indirect RAM to Acc with carry
ADDC    A,#<immed>          Add Immediate data to Acc with carry
ADDC    A,<direct>          Add Direct RAM to Acc with carry

AJMP    <addr11>            Absolute Jump

ANL     A,Rn                AND Register and Acc
ANL     A,@R0               AND Indirect RAM and Acc
ANL     A,@R1               AND Indirect RAM and Acc
ANL     A,#<immed>          AND Immediate data and Acc
ANL     A,<direct>          AND Direct RAM and Acc
ANL     C,/<direct>         AND Complement of direct bit to Carry
ANL     C,<direct>          AND direct bit to Carry
ANL     <direct>,A          AND Acc to direct RAM
ANL     <direct>,#<immed>   AND Immediate data and direct RAM

CJNE    A,#<immed>,<rel>    Compare Immediate to Acc   and JNE
CJNE    A,<direct>,<rel>    Compare direct RAM to Acc and JNE
CJNE    Rn,#<immed>,<rel>   Compare Immediate to Register and JNE
CJNE    @R0,#<immed>,<rel>  Compare Immediate to Indirect RAM and JNE
CJNE    @R1,#<immed>,<rel>  Compare Immediate to Indirect RAM and JNE

CLR     A                   Clear Accumulator
CLR     C                   Clear Carry
CLR     <direct>            Clear Direct RAM

CPL     A                   Complement Accumulator
TASM TABLES  Version 2.8                                      Page 9

CPL     C                   Complement Carry
CPL     <direct>            Complement Direct RAM

DA      A                   Decimal Adjust Accumulator
DEC     A                   Decrement Acc
DEC     Rn                  Decrement Register
DEC     @R0                 Decrement Indirect RAM
DEC     @R1                 Decrement Indirect RAM
DEC     <direct>            Decrement Direct RAM

DIV     AB                  Divide Acc by B

DJNZ    Rn,<rel>            Decrement Register and JNZ
DJNZ    <direct>,<rel>      Decrement Direct RAM and JNZ

INC     A                   Increment Acc
INC     Rn                  Increment Register
INC     @R0                 Increment Indirect RAM
INC     @R1                 Increment Indirect RAM
INC     DPTR                Increment Data Pointer
INC     <direct>            Increment Direct RAM

JB      <bit>,<rel>         Jump if Bit is set
JBC     <bit>,<rel>         Jump if Bit is set & clear Bit
JC      <rel>               Jump if Carry is set
JMP     @A+DPTR             Jump indirect relative to Data Pointer
JNB     <bit>,<rel>         Jump if Bit is clear
JNC     <rel>               Jump if Carry is clear
JNZ     <rel>               Jump if Acc is not zero
JZ      <rel>               Jump if Acc is zero

LCALL   <addr16>            Long Subroutine Call
LJMP    <addr16>            Long Jump

MOV     A,Rn                Move Register to Acc
MOV     A,@R0               Move Indirect RAM to Acc
MOV     A,@R1               Move Indirect RAM to Acc
MOV     A,#<immed>          Move Immediate data to Acc
MOV     A,<direct>          Move direct RAM to Acc
MOV     C,<bit>             Move bit to Acc
MOV     DPTR,#<immed>       Move immediate data to Data Pointer
MOV     Rn,A                Move Acc to Register
MOV     Rn,#<immed>         Move Immediate data to Register
MOV     Rn,<direct>         Move Direct RAM to Register
MOV     @R0,A               Move Acc to Indirect RAM
MOV     @R1,A               Move Acc to Indirect RAM
MOV     @R0,#<immed>        Move Immediate data to Indirect RAM
MOV     @R1,#<immed>        Move Immediate data to Indirect RAM
MOV     @R0,<direct>        Move Direct RAM to Indirect RAM
MOV     @R1,<direct>        Move Direct RAM to Indirect RAM
MOV     <direct>,A          Move Acc to Direct RAM
MOV     <bit>,C             Move Carry to Bit
MOV     <direct>,Rn         Move Register to Direct RAM
MOV     <direct>,@R0        Move Indirect RAM to Direct RAM
MOV     <direct>,@R1        Move Indirect RAM to Direct RAM
MOV     <direct>,#<immed>   Move Immediate data to Direct RAM
TASM TABLES  Version 2.8                                     Page 10

MOV     <direct>,<direct>   Move Direct RAM to Direct RAM
MOVC    A,@A+DPTR           Move code byte relative to DPTR to Acc
MOVC    A,@A+PC             Move code byte relative to PC to Acc

MOVX    A,@R0               Move external RAM to Acc
MOVX    A,@R1               Move external RAM to Acc
MOVX    A,@DPTR             Move external RAM to Acc (16 bit addr)
MOVX    @R0,A               Move Acc to external RAM
MOVX    @R1,A               Move Acc to external RAM
MOVX    @DPTR,A             Move Acc to external RAM (16 bit addr)

MUL     AB                  Multiply Acc by B

NOP                         No operation

ORL     A,Rn                OR Register and Acc
ORL     A,@R0               OR Indirect RAM and Acc
ORL     A,@R1               OR Indirect RAM and Acc
ORL     A,#<immed>          OR Immediate data and Acc
ORL     A,<direct>          OR Direct RAM and Acc
ORL     C,/<direct>         OR Complement of direct bit to Carry
ORL     C,<direct>          OR direct bit to Carry
ORL     <direct>,A          OR Acc to direct RAM
ORL     <direct>,#<immed>   OR Immediate data and direct RAM

POP     <direct>            Pop  from Stack and put in Direct RAM
PUSH    <direct>            Push from Direct RAM to Stack

RET                         Return from subroutine
RETI                        Return from Interrupt

RL      A                   Rotate Acc left
RLC     A                   Rotate Acc left through Carry
RR      A                   Rotate Acc right
RRC     A                   Rotate Acc right through Carry

SETB    C                   Set the Carry Bit
SETB    <bit>               Set Direct Bit

SJMP    <rel>               Short jump

SUBB    A,Rn                Subtract Register from Acc with Borrow
SUBB    A,@R0               Subtract Indirect RAM from Acc w/ Borrow
SUBB    A,@R1               Subtract Indirect RAM from Acc w/ Borrow
SUBB    A,#<immed>          Subtract Immediate data from Acc w/ Borrow
SUBB    A,<direct>          Subtract Direct RAM from Acc w/ Borrow

SWAP    A                   Swap nibbles of Acc

XCH     A,Rn                Exchange Acc with Register
XCH     A,@R0               Exchange Acc with Indirect RAM
XCH     A,@R1               Exchange Acc with Indirect RAM
XCH     A,<direct>          Exchange Acc with Direct RAM

XCHD    A,@R0               Exchange Digit in Acc with Indirect RAM
XCHD    A,@R1               Exchange Digit in Acc with Indirect RAM
TASM TABLES  Version 2.8                                     Page 11

XRL     A,Rn                Exclusive OR Register and Acc
XRL     A,@R0               Exclusive OR Indirect RAM and Acc
XRL     A,@R1               Exclusive OR Indirect RAM and Acc
XRL     A,#<immed>          Exclusive OR Immediate data and Acc
XRL     A,<direct>          Exclusive OR Direct RAM and Acc
XRL     <direct>,A          Exclusive OR Acc to direct RAM
XRL     <direct>,#<immed>   Exclusive OR Immediate data and direct RAM

Note  that  the above tables do not automatically define the various
mnemonics that may be  used  for  addressing  the  special  function
registers  of  the  8051.  The  user  may  wish  to set up a file of
equates (EQU's) that can be included in the  source  file  for  this
purpose.  The following illustrates some of the appropriate equates:


P0      .equ    080H    ;Port 0
SP      .equ    081H    ;Stack pointer
DPL     .equ    082H
DPH     .equ    083H
PCON    .equ    087H
TCON    .equ    088H
TMOD    .equ    089H
TL0     .equ    08AH
TL1     .equ    08BH
TH0     .equ    08CH
TH1     .equ    08DH
P1      .equ    090H    ;Port 1
SCON    .equ    098H
SBUF    .equ    099H
P2      .equ    0A0H    ;Port 2
IEC     .equ    0A8H
P3      .equ    0B0H    ;Port 3
IPC     .equ    0B8H
PSW     .equ    0D0H
ACC     .equ    0E0H    ;Accumulator
B       .equ    0F0H    ;Secondary Accumulator
;Now some bit addresses
P0.0    .equ    080H    ;Port 0 bit 0
P0.1    .equ    081H    ;Port 0 bit 1
P0.2    .equ    082H    ;Port 0 bit 2
P0.3    .equ    083H    ;Port 0 bit 3
P0.4    .equ    080H    ;Port 0 bit 4
P0.5    .equ    081H    ;Port 0 bit 5
P0.6    .equ    082H    ;Port 0 bit 6
P0.7    .equ    083H    ;Port 0 bit 7
ACC.0   .equ    0E0H    ;Acc bit 0
ACC.1   .equ    0E1H    ;Acc bit 1
ACC.2   .equ    0E2H    ;Acc bit 2
ACC.3   .equ    0E3H    ;Acc bit 3
ACC.4   .equ    0E4H    ;Acc bit 4
ACC.5   .equ    0E5H    ;Acc bit 5
ACC.6   .equ    0E6H    ;Acc bit 6
ACC.7   .equ    0E7H    ;Acc bit 7

See  the   manufacturer's   data  sheets   for   more   information.
TASM TABLES  Version 2.8                                     Page 12

8085 INSTRUCTIONS AND ADDRESSING MODES

The following list shows the acceptable opcode mnemonics  and  their
corresponding  operand  formats for the 8085  version of TASM.   The
following symbols are used in the table:

        SYMBOLIC            DESCRIPTION
        -----------------------------------------------
        <addr>              Absolute address (16 bits)
        <data>              Immediate data (8 bits)
        <data16>            Immediate data (16 bits)
        <reg>               Register (A,B,C,D,E,H,L)
        <rp>                Register pair (B,D,H,SP)
        <port>              Port address (0-255)
        <int>               Interrupt level (0 - 7)

Any valid TASM expression can appear in the  place  of  any  of  the
above symbolics except <reg>, <rp> and <int>.

OPCODE  OPERAND        DESCRIPTION
--------------------------------------------------------------------
ACI      <data>         Add immediate to A with carry
ADC      <reg>          Add <reg> to A with carry
ADC      M              Add indirect memory (HL) with carry
ADD      <reg>          Add <reg> to A
ADD      M              Add indirect memory (HL) to A
ADI      <data>         Add immediate to A

ANA      <reg>          And register with A
ANA      M              And indirect memory (HL) to A
ANI      <data>         And immediate to A

CALL     <addr>         Call subroutine at <addr>
CC       <addr>         Call subroutine if carry set
CNC      <addr>         Call subroutine if carry clear
CZ       <addr>         Call subroutine if zero
CNZ      <addr>         Call subroutine if non zero
CP       <addr>         Call subroutine if positive
CM       <addr>         Call subroutine if negative
CPE      <addr>         Call subroutine if even parity
CPO      <addr>         Call subroutine if odd  parity
CMA                     Complement A
CMC                     Complemennt carry
CMP      <reg>          Compare register with A
CMP      M              Compare indirect memory (HL) with A
CPI      <data>         Compare immediate data with A

DAA                     Decimal adjust A
DAD      <rp>           Add register pair to HL
DCR      <reg>          Decrement register
DCR      M              Decrement indirect memory (HL)
DCX      <rp>           Decrement register pair

DI                      Disable interrupts
EI                      Enable interrupts
HLT                     Halt
TASM TABLES  Version 2.8                                     Page 13

IN       <port>         Input on port
INR      <reg>          Increment register
INR      M              Increment indirect memory (HL)
INX      <rp>           Increment register pair

JMP      <addr>         Jump
JC       <addr>         Jump if carry set
JNC      <addr>         Jump if carry clear
JZ       <addr>         Jump if zero
JNZ      <addr>         Jump if not zero
JM       <addr>         Jump if minus
JP       <addr>         Jump if plus
JPE      <addr>         Jump if parity even
JPO      <addr>         Jump if parity odd

LDA      <addr>         Load A direct from memory
LDAX     B              Load A indirect from memory using BC
LDAX     D              Load A indirect from memory using DE
LHLD     <addr>         Load HL direct from memory
LXI      <rp>,<data16>  Load register pair with immediate data

MOV      <reg>,<reg>    Move register to register
MOV      <reg>,M        Move indirect memory (HL) to register
MVI      <reg>,<data>   Move immediate data to register

NOP                     No operation

ORA      <reg>          Or register with A
ORA      M              Or indirect memory (HL) with A
ORI      <data>         Or immediate data to A
OUT      <port>         Ouput to port

PCHL                    Jump to instruction at (HL)
POP      <rp>           Pop  register pair (excluding SP) from stack
PUSH     <rp>           Push register pair (excluding SP) onto stack
POP      PSW            Pop  PSW from stack
PUSH     PSW            Pop  PSW onto stack

RAL                     Rotate A left  with carry
RAR                     Rotate A right with carry
RLC                     Rotate A left  with branch carry
RRC                     Rotate A right with branch carry

RET                     Return from subroutine
RZ                      Return if zero
RNZ                     Return if non zero
RC                      Return if carry set
RNC                     Return if carry clear
RM                      Return if minus
RP                      Return if plus
RPE                     Return if parity even
RPO                     Return if parity odd

RIM                     Read interrupt mask
RST      <int>          Restart at vector <int>

TASM TABLES  Version 2.8                                     Page 14

SBB      <reg>          Subtract <reg> from A         with borrow
SBB      M              Subtract indirect memory (HL) with borrow
SBI      <data>         Subtract immediate from A     with borrow
SUB      <reg>          Subtract <reg> from A
SUB      M              Subtract indirect memory (HL) from A
SUI      <data>         Subtract immediate from A

SHLD     <addr>         Store HL
SIM                     Store Interrupt mask
SPHL                    Exchange SP with HL

STA      <addr>         Store A direct memory
STAX     B              Store A indirect using BC
STAX     D              Store A indirect using DE

STC                     Set carry

XRA      <reg>          Exclusive OR A with register
XRA      M              Exclusive Or A with indirect memory (HL)
XRI      <data>         Exclusive Or A with immediate data
XCHG                    Exchange DE with HL
XTHL                    Exchange HL with top of stack

See  the   manufacturer's   data  sheets   for   more   information.
TASM TABLES  Version 2.8                                     Page 15

Z80 INSTRUCTIONS AND ADDRESSING MODES

The following list shows the acceptable opcode mnemonics  and  their
corresponding   operand  formats for the Z80  version of TASM.   The
following symbols are used in the table:
        SYMBOLIC            DESCRIPTION
        -----------------------------------------------
        <addr>              Absolute address (16 bits)
        <bit>               Bit address
        <data>              Immediate data (8 bits)
        <data16>            Immediate data (16 bits)
        <disp>              Relative address
        <reg>               Register (A, B, C, D, E, H, or L)
        <rp>                Register pair (BC, DE, HL, or SP)
        <port>              Port (0 - 255)
        <cond>              Condition
                                NZ - not zero
                                Z  - zero
                                NC - not carry
                                C  - carry
                                PO - parity odd
                                PE - parity even
                                P  - positive
                                M  - minus

Any valid TASM expression can appear in the  place  of the   <addr>,
<bit>, <data>, <data16>, or <disp> symbolics.

OPCODE  OPERAND         DESCRIPTION
--------------------------------------------------------------------
ADC  A,<data>           Add immediate with carry to accumulator
ADC  A,<reg>            Add register with carry to accumulator
ADC  A,(HL)             Add indirect memory with carry to accumulator
ADC  A,(IX+<disp>)      Add indirect memory with carry to accumulator
ADC  A,(IY+<disp>)      Add indirect memory with carry to accumulator
ADC  HL,<rp>            Add register pair with carry to HL

ADD  A,<data>           Add immediate to accumulator
ADD  A,<reg>            Add register to accumulator
ADD  A,(HL)             Add indirect memory to accumulator
ADD  A,(IX+<disp>)      Add indirect memory to accumulator
ADD  A,(IY+<disp>)      Add indirect memory to accumulator
ADD  HL,<rp>            Add register pair to HL
ADD  IX,<rp>            Add register pair to index register
ADD  IY,<rp>            Add register pair to index register

AND  <data>             And immediate with accumulator
AND  <reg>              And register  with accumulator
AND  (HL)               And memory with accumulator
AND  (IX+<disp>)        And memory with accumulator
AND  (IY+<disp>)        And memory with accumulator

BIT  <bit>,<reg>        Test <bit> in register
BIT  <bit>,(HL)         Test <bit> in indirect memory
BIT  <bit>,(IY+<disp>)  Test <bit> in indirect memory
BIT  <bit>,(IX+<disp>)  Test <bit> in indirect memory
TASM TABLES  Version 2.8                                     Page 16

CALL <addr>             Call the routine at <addr>
CALL <cond>,<addr>      Call the routine if <cond> is satisfied

CCF                     Complement carry flag

CP   <data>             Compare immediate data with accumulator
CP   <reg>              Compare register with accumulator
CP   (HL)               Compare indirect memory with accumulator
CP   (IX+<disp>)        Compare indirect memory with accumulator
CP   (IY+<disp>)        Compare indirect memory with accumulator
CPD                     Compare accumulator with memory and
                            decrement address and byte counters
CPDR                    Compare accumulator with memory and
                            decrement address and byte counter,
                            continue until match is found or
                            byte counter is zero

CPI                     Compare accumulator with memory and
                            increment address and byte counters
CPIR                    Compare accumulator with memory and
                            increment address and byte counter,
                            continue until match is found or
                            byte counter is zero
CPL                     Complement the accumulator
DAA                     Decimal adjust accumulator
DEC  <reg>              Decrement register contents
DI                      Disable interrupts
DJNZ <disp>             Decrement reg B and jump relative if zero
EI                      Enable interrupts
EX   AF,AF'             Exchange program status and alt program stat
EX   DE,HL              Exchange DE and HL contents
EX   (SP),HL            Exchange contents of HL and top of stack
EX   (SP),IX            Exchange contents of IX and top of stack
EX   (SP),IY            Exchange contents of IY and top of stack
EXX                     Exchange register pairs and alt reg pairs
HALT                    Program execution stops
IM   0                  Interrupt mode 0
IM   1                  Interrupt mode 1
IM   2                  Interrupt mode 2
IN   A,<port>           Input port to accumulator
INC  <reg>              Increment contents of register
INC  <rp>               Increment contents of register pair
INC  IX                 Increment IX
INC  IY                 Increment IY
INC  (HL)               Increment indirect memory
INC  (IX+<disp>)        Increment indirect memory
INC  (IY+<disp>)        Increment indirect memory
IND                     Input to memory and decrement pointer
INDR                    Input to memory and decrement pointer until
                            byte counter is zero
INI                     Input to memory and increment pointer
INIR                    Input to memory and increment pointer until
                            byte counter is zero
IN   <reg>,(C)          Input to register

JP   <addr>             Jump to location
TASM TABLES  Version 2.8                                     Page 17

JP   <cond>,<addr>      Jump to location if condition satisifed
JP   (HL)               Jump to location pointed to by HL
JP   (IX)               Jump to location pointed to by IX
JP   (IY)               Jump to location pointed to by IY

JR   <disp>             Jump relative
JR   C,<disp>           Jump relative if carry is set
JR   NC,<disp>          Jump relative if carry bit is reset
JR   NZ,<disp>          Jump relative if zero flag is reset
JR   Z,<disp>           Jump relative if zero flag is set

LD   A,I                Move interrupt vector contents to accumulator
LD   A,R                Move refresh reg contents to accumulator
LD   A,(<addr>)         Load accumulator indirect from memory
LD   A,(<rp>)           Load accumulator indirect from memory by <rp>
LD   <reg>,<reg>        Load source register to destination register
LD   <rp>,(<addr>)      Load register pair indirect from memory
LD   IX,(<addr>)        Load IX indirect from memory
LD   IY,(<addr>)        Load IY indirect from memory
LD   I,A                Load interrup vector from accumulator
LD   R,A                Load refresh register from accumulator
LD   <reg>,<data>       Load register with immediate data
LD   <rp>,<data16>      Load register pair with immediate data
LD   IX,<data16>        Load  IX  with immediate data
LD   IY,<data16>        Load  IY  with immediate data
LD   <reg>,(HL)         Load register indirect from memory
LD   <reg>,(IX+<disp>)  Load register indirect from memory
LD   <reg>,(IY+<disp>)  Load register indirect from memory
LD   SP,HL              Load contents of HL to stack pointer
LD   SP,IX              Load contents of IX to stack pointer
LD   SP,IY              Load contents of IY to stack pointer
LD   (addr),A           Load contents of A to memory
LD   (<addr>),HL        Load contents of HL to memory
LD   (<addr>),<rp>      Load contents of register pair to memory
LD   (<addr>),IX        Load contents of IX to memory
LD   (<addr>),IY        Load contents of IY to memory
LD   (HL),<data>        Load immediate into indirect memory
LD   (IX+<disp>),<data> Load immediate into indirect memory
LD   (IY+<disp>),<data> Load immediate into indirect memory
LD   (HL),<reg>         Load register  into indirect memory
LD   (IX+<disp>),<reg>  Load register  into indirect memory
LD   (IY+<disp>),<reg>  Load register  into indirect memory
LD   (<rp>),A           Load accumulator into indirect memory
LDD                     Transfer data between memory and decrement
                            destination and source addresses
LDDR                    Transfer data between memory until byte
                            counter is zero, decrement destintation
                            and source addresses
LDI                     Transfer data between memory and increment
                            destination and source addresses
LDIR                    Transfer data between memory until byte
                            counter is zero, increment destination
                            and source addresses
NEG                     Negate contents of accumulator
NOP                     No operation
OR   <data>             Or immediate with accumulator
TASM TABLES  Version 2.8                                     Page 18

OR   <reg>              Or register with accumulator
OR   (HL)               Or indirect memory with accumulator
OR   (IX+<disp>)        Or indirect memory with accumulator
OR   (IY+<disp>)        Or indirect memory with accumulator
OUT  (C),<reg>          Output from registor
OUTD                    Output from memory, decrement address
OTDR                    Output from memory, decrement address
                            continue until reg B is zero
OUTI                    Output from memory, increment address
OTIR                    Output from memory, increment address
                            continue until reg B is zero
OUT  <port>,A           Output from accumulator
POP  <rp>               Load register pair from top of stack
POP  IX                 Load IX from top of stack
POP  IY                 Load IY from top of stack
PUSH <rp>               Store resister pair on top of stack
PUSH IX                 Store IX on top of stack
PUSH IY                 Store IY on top of stack
RES  <bit>,<reg>        Reset register bit
RES  <bit>,(HL)         Reset bit at indirect memory location
RES  <bit>,(IX+disp)    Reset bit at indirect memory location
RES  <bit>,(IY+<disp>)  Reset bit at indirect memory location
RET                     Return from subroutine
RET  <cond>             Return from subroutine if condition true
RETI                    Return from interrupt
RETN                    Return from non-maskable interrupt
RL   <reg>              Rotate left through carry register contents
RL   (HL)               Rotate left through carry indirect memory
RL   (IX+<disp>)        Rotate left through carry indirect memory
RL   (IY+<disp>)        Rotate left through carry indirect memory
RLA                     Rotate left through carry accumulator
RLC  <reg>              Rotate left branch  carry register contents
RLC  (HL)               Rotate left branch  carry indirect memory
RLC  (IX+<disp>)        Rotate left branch  carry indirect memory
RLC  (IY+<disp>)        Rotate left branch  carry indirect memory
RLCA                    Rotate left accumulator
RLD                     Rotate one BCD digit left between the
                            accumulator and memory
RR   <reg>              Rotate right through carry register contents
RR   (HL)               Rotate right through carry indirect memory
RR   (IX+<disp>)        Rotate right through carry indirect memory
RR   (IY+<disp>)        Rotate right through carry indirect memory
RRA                     Rotate right through carry accumulator
RRC  <reg>              Rotate right branch  carry register contents
RRC  (HL)               Rotate right branch  carry indirect memory
RRC  (IX+<disp>)        Rotate right branch  carry indirect memory
RRC  (IY+<disp>)        Rotate right branch  carry indirect memory
RRCA                    Rotate right branch  carry accumulator
RRD                     Rotate one BCD digit right between the
                            accumulator and memory
RST                     Restart
SBC  A,<data>           Subtract data            from A with borrow
SBC  A,<reg>            Subtract register        from A with borrow
SBC  A,(HL)             Subtract indirect memory from A with borrow
SBC  A,(IX+<disp>)      Subtract indirect memory from A with borrow
SBC  A,(IY+<disp>)      Subtract indirect memory from A with borrow
TASM TABLES  Version 2.8                                     Page 19

SBC  HL,<rp>            Subtract register pair from HL with borrow
SCF                     Set carry flag
SET  <bit>,<reg>        Set register bit
SET  <bit>,(HL)         Set indirect memory bit
SET  <bit>,(IX+<disp>)  Set indirect memory bit
SET  <bit>,(IY+<disp>)  Set indirect memory bit
SLA  <reg>              Shift register left arithmetic
SLA  (HL)               Shift indirect memory left arithmetic
SLA  (IX+<disp>)        Shift indirect memory left arithmetic
SLA  (IY+<disp>)        Shift indirect memory left arithmetic
SRA  <reg>              Shift register right arithmetic
SRA  (HL)               Shift indirect memory right arithmetic
SRA  (IX+<disp>)        Shift indirect memory right arithmetic
SRA  (IY+<disp>)        Shift indirect memory right arithmetic
SRL  <reg>              Shift register right logical
SRL  (HL)               Shift indirect memory right logical
SRL  (IX+<disp>)        Shift indirect memory right logical
SRL  (IY+<disp>)        Shift indirect memory right logical
SUB  <data>             Subtract immediate from accumulator
SUB  <reg>              Subtract register from accumulator
SUB  (HL)               Subtract indirect memory from accumulator
SUB  (IX+<disp>)        Subtract indirect memory from accumulator
SUB  (IY+<disp>)        Subtract indirect memory from accumulator
XOR  <data>             Exclusive or immediate with accumulator
XOR  <reg>              Exclusive or register with accumulator
XOR  (HL)               Exclusive or indirect memory with accumulator
XOR  (IX+<disp>)        Exclusive or indirect memory with accumulator
XOR  (IY+<disp>)        Exclusive or indirect memory with accumulator

See  the   manufacturer's   data  sheets   for   more   information.
TASM TABLES  Version 2.8                                     Page 20

6805 INSTRUCTIONS AND ADDRESSING MODES

The following list shows the acceptable opcode mnemonics  and  their
corresponding  operand  formats for the 6805  version of TASM.   The
following symbols are used in the table:

        SYMBOLIC            DESCRIPTION
        -----------------------------------------------
        <addr>              Absolute address (16 bits)
        <addr8>             Absolute address (8 bits)
        <bit>               Bit address
        <data>              Immediate data (8 bits)
        <rel>               Relative address

Any valid TASM expression can appear in the  place  of the   <addr>,
<addr8>, <bit>, <data>, or <rel> symbolics.

OPCODE  OPERAND         DESCRIPTION
--------------------------------------------------------------
ADC     #<data>         Add with carry, immediate
ADC     ,X              Add with carry, indexed, no offset
ADC     <addr8>,X       Add with carry, indexed, 1 byte offset
ADC     <addr>,X        Add with carry, indexed, 2 byte offset
ADC     <addr8>         Add with carry, direct
ADC     <addr>          Add with carry, extended

ADD     #<data>         Add, immediate
ADD     ,X              Add, indexed, no offset
ADD     <addr8>,X       Add, indexed, 1 byte offset
ADD     <addr>,X        Add, indexed, 2 byte offset
ADD     <addr8>         Add, direct
ADD     <addr>          Add, extended

AND     #<data>         And, immediate
AND     ,X              And, indexed, no offset
AND     <addr8>,X       And, indexed, 1 byte offset
AND     <addr>,X        And, indexed, 2 byte offset
AND     <addr8>         And, direct
AND     <addr>          And, extended

ASLA                    Arithmetic Shift Left, accumulator
ASLX                    Arithmetic Shift Left, index register
ASL     <addr8>         Arithmetic Shift Left, direct
ASL     ,X              Arithmetic Shift Left, indexed, no offset
ASL     <addr8>,X       Arithmetic Shift Left, indexed, 1 byte offset

ASRA                    Arithmetic Shift Right, accumulator
ASRX                    Arithmetic Shift Right, index register
ASR     <addr8>         Arithmetic Shift Right, direct
ASR     ,X              Arithmetic Shift Right, indexed, no offset
ASR     <addr8>,X       Arithmetic Shift Right, indexed, 1 byte offset

BCC     <rel>           Branch if carry clear
BCLR    <bit>,<addr8>   Bit Clear in memory
BCS     <rel>           Branch if carry set
BEQ     <rel>           Branch if equal
TASM TABLES  Version 2.8                                     Page 21

BHCC    <rel>           Branch if half carry clear
BHCS    <rel>           Branch if half carry set
BHI     <rel.           Branch if higher
BHS     <rel>           Branch if higher or same
BIH     <rel>           Branch if interrupt line is high
BIL     <rel>           Branch if interrupt is low

BIT     #<data>         Bit test, immediate
BIT     ,X              Bit test, indexed, no offset
BIT     <addr8>,X       Bit test, indexed, 1 byte offset
BIT     <addr>,X        Bit test, indexed, 2 byte offset
BIT     <addr8>         Bit test, direct
BIT     <addr>          Bit test, extended

BLO     <rel>           Branch if lower
BLS     <rel>           Branch if lower or same
BMC     <rel>           Branch if interrupt mask is clear
BMI     <rel>           Branch if minus
BMS     <rel>           Branch if interuupt mask bit is set
BNE     <rel>           Branch if not equal
BPL     <rel>           Branch if plus
BRA     <rel>           Branch always
BRCLR   <bit>,<addr8>,<rel>     Branch if bit is clear
BRN     <rel>           Branch never
BRSET   <bit>,<addr8>,<rel>     Branch if bit is set
BSET    <bit>,<addr8>   Bit set in memory
BSR     <rel>           Branch to subroutine

CLC                     Clear carry bit
CLI                     Clear interuupt mask bit

CLRA                    Clear, accumulator
CLRX                    Clear, index register
CLR     <addr8>         Clear, direct
CLR     ,X              Clear, indexed, no offset
CLR     <addr8>,X       Clear, indexed, 1 byte offset

CMP     #<data>         Compare Acc, immediate
CMP     ,X              Compare Acc, indexed, no offset
CMP     <addr8>,X       Compare Acc, indexed, 1 byte offset
CMP     <addr>,X        Compare Acc, indexed, 2 byte offset
CMP     <addr8>         Compare Acc, direct
CMP     <addr>          Compare Acc, extended

COMA                    Complement, accumulator
COMX                    Complement, index register
COM     <addr8>         Complement, direct
COM     ,X              Complement, indexed, no offset
COM     <addr8>,X       Complement, indexed, 1 byte offset

CPX     #<data>         Compare Index, immediate
CPX     ,X              Compare Index, indexed, no offset
CPX     <addr8>,X       Compare Index, indexed, 1 byte offset
CPX     <addr>,X        Compare Index, indexed, 2 byte offset
CPX     <addr8>         Compare Index, direct
CPX     <addr>          Compare Index, extended
TASM TABLES  Version 2.8                                     Page 22

DECA                    Decrement, accumulator
DECX                    Decrement, index register
DEX                     Decrement, index register (alternate of DECX)
DEC     <addr8>         Decrement, direct
DEC     ,X              Decrement, indexed, no offset
DEC     <addr8>,X       Decrement, indexed, 1 byte offset

EOR     #<data>         Exclusive OR, immediate
EOR     ,X              Exclusive OR, indexed, no offset
EOR     <addr8>,X       Exclusive OR, indexed, 1 byte offset
EOR     <addr>,X        Exclusive OR, indexed, 2 byte offset
EOR     <addr8>         Exclusive OR, direct
EOR     <addr>          Exclusive OR, extended

INCA                    Increment, accumulator
INCX                    Increment, index register
INX                     Increment, index register (alternate of INCX)
INC     <addr8>         Increment, direct
INC     ,X              Increment, indexed, no offset
INC     <addr8>,X       Increment, indexed, 1 byte offset

JMP     ,X              Jump, indexed, no offset
JMP     <addr8>,X       Jump, indexed, 1 byte offset
JMP     <addr>,X        Jump, indexed, 2 byte offset
JMP     <addr8>         Jump, direct
JMP     <addr>          Jump, extended

JSR     ,X              Jump Subroutine, indexed, no offset
JSR     <addr8>,X       Jump Subroutine, indexed, 1 byte offset
JSR     <addr>,X        Jump Subroutine, indexed, 2 byte offset
JSR     <addr8>         Jump Subroutine, direct
JSR     <addr>          Jump Subroutine, extended

LDA     #<data>         Load Acc, immediate
LDA     ,X              Load Acc, indexed, no offset
LDA     <addr8>,X       Load Acc, indexed, 1 byte offset
LDA     <addr>,X        Load Acc, indexed, 2 byte offset
LDA     <addr8>         Load Acc, direct
LDA     <addr>          Load Acc, extended

LDX     #<data>         Load Index, immediate
LDX     ,X              Load Index, indexed, no offset
LDX     <addr8>,X       Load Index, indexed, 1 byte offset
LDX     <addr>,X        Load Index, indexed, 2 byte offset
LDX     <addr8>         Load Index, direct
LDX     <addr>          Load Index, extended

LSLA                    Logical Shift Left, accumulator
LSLX                    Logical Shift Left, index register
LSL     <addr8>         Logical Shift Left, direct
LSL     ,X              Logical Shift Left, indexed, no offset
LSL     <addr8>,X       Logical Shift Left, indexed, 1 byte offset

LSRA                    Logical Shift Right, accumulator
LSRX                    Logical Shift Right, index register
LSR     <addr8>         Logical Shift Right, direct
TASM TABLES  Version 2.8                                     Page 23

LSR     ,X              Logical Shift Right, indexed, no offset
LSR     <addr8>,X       Logical Shift Right, indexed, 1 byte offset

NEGA                    Negate, accumulator
NEGX                    Negate, index register
NEG     <addr8>         Negate, direct
NEG     ,X              Negate, indexed, no offset
NEG     <addr8>,X       Negate, indexed, 1 byte offset

NOP                     No Operation

ORA     #<data>         Inclusive OR Acc, immediate
ORA     ,X              Inclusive OR Acc, indexed, no offset
ORA     <addr8>,X       Inclusive OR Acc, indexed, 1 byte offset
ORA     <addr>,X        Inclusive OR Acc, indexed, 2 byte offset
ORA     <addr8>         Inclusive OR Acc, direct
ORA     <addr>          Inclusive OR Acc, extended

ROLA                    Rotate Left thru Carry, accumulator
ROLX                    Rotate Left thru Carry, index register
ROL     <addr8>         Rotate Left thru Carry, direct
ROL     ,X              Rotate Left thru Carry, indexed, no offset
ROL     <addr8>,X       Rotate Left thru Carry, indexed, 1 byte offset

RORA                    Rotate Right thru Carry, accumulator
RORX                    Rotate Right thru Carry, index register
ROR     <addr8>         Rotate Right thru Carry, direct
ROR     ,X              Rotate Right thru Carry, indexed, no offset
ROR     <addr8>,X       Rotate Right thru Carry, indexed, 1 byte offset

RSP                     Reset Stack Pointer
RTI                     Return from Interrupt
RTS                     Return from Subroutine

SBC     #<data>         Subtract with Carry, immediate
SBC     ,X              Subtract with Carry, indexed, no offset
SBC     <addr8>,X       Subtract with Carry, indexed, 1 byte offset
SBC     <addr>,X        Subtract with Carry, indexed, 2 byte offset
SBC     <addr8>         Subtract with Carry, direct
SBC     <addr>          Subtract with Carry, extended

SEC                     Set carry bit
SEI                     Set interrupt Mask bit

STA     #<data>         Store Acc, immediate
STA     ,X              Store Acc, indexed, no offset
STA     <addr8>,X       Store Acc, indexed, 1 byte offset
STA     <addr>,X        Store Acc, indexed, 2 byte offset
STA     <addr8>         Store Acc, direct
STA     <addr>          Store Acc, extended

STOP                    Enable IRQ, Stop Oscillator

STX     #<data>         Store Index, immediate
STX     ,X              Store Index, indexed, no offset
STX     <addr8>,X       Store Index, indexed, 1 byte offset
TASM TABLES  Version 2.8                                     Page 24

STX     <addr>,X        Store Index, indexed, 2 byte offset
STX     <addr8>         Store Index, direct
STX     <addr>          Store Index, extended

SUB     #<data>         Subtract, immediate
SUB     ,X              Subtract, indexed, no offset
SUB     <addr8>,X       Subtract, indexed, 1 byte offset
SUB     <addr>,X        Subtract, indexed, 2 byte offset
SUB     <addr8>         Subtract, direct
SUB     <addr>          Subtract, extended

SWI                     Software Interrupt

TAX                     Transfer Acc to Index

TSTA                    Test for neg or zero, accumulator
TSTX                    Test for neg or zero, index register
TST     <addr8>         Test for neg or zero, direct
TST     ,X              Test for neg or zero, indexed, no offset
TST     <addr8>,X       Test for neg or zero, indexed, 1 byte offset

TXA                     Transfer Index to Acc

WAIT                    Enable Interrupt, Stop Processor

See  the   manufacturer's   data  sheets   for   more   information.
TASM TABLES  Version 2.8                                     Page 25

TMS32010 INSTRUCTIONS AND ADDRESSING MODES

The following list shows the acceptable opcode mnemonics  and  their
corresponding   operand  formats for the TMS32010   version of TASM.
The following symbols are used in the table:

        SYMBOLIC            DESCRIPTION
        -----------------------------------------------
        <ar>                Auxiliary register (AR0, AR1)
        <arp>               Auxiliary register pointer
        <dma>               Direct memory address
        <pma>               Program memory address
        <port>              Port address (0 - 7)
        <shift>             Shift count  (0 - 15)
        <const1>            Constant (1 bit)
        <const8>            Constant (8 bit)
        <const13>           Constant (13 bit)

Any valid TASM expression can appear in the  place  of  any  of  the
above symbolics.

OPCODE   OPERAND            DESCRIPTION
--------------------------------------------------------------------
ABS                         Absolute value of ACC

ADD      *+,<shift>,<arp>   Add to ACC with shift
ADD      *-,<shift>,<arp>
ADD      *, <shift>,<arp>
ADD      *+,<shift>
ADD      *-,<shift>
ADD      *, <shift>
ADD      *+
ADD      *-
ADD      *
ADD      <dma>,<shift>
ADD      <dma>

ADDH     *+,<arp>           Add to high-order ACC bits
ADDH     *-,<arp>
ADDH     *, <arp>
ADDH     *+
ADDH     *-
ADDH     *
ADDH     <dma>

ADDS     *+,<arp>           Add to ACC with no sign extension
ADDS     *-,<arp>
ADDS     *, <arp>
ADDS     *+
ADDS     *-
ADDS     *
ADDS     <dma>

AND      *+,<arp>           AND with ACC
AND      *-,<arp>
AND      *, <arp>
TASM TABLES  Version 2.8                                     Page 26

AND      *+
AND      *-
AND      *
AND      <dma>

APAC                        Add P register to ACC

B        <pma>              Branch unconditionally
BANZ     <pma>              Branch on auxiliary register not zero
BGEZ     <pma>              Branch if ACC >= 0
BGZ      <pma>              Branch if ACC >  0
BIOZ     <pma>              Branch on BIO- = 0
BLEZ     <pma>              Branch if ACC <= 0
BLZ      <pma>              Branch if ACC <  0
BNZ      <pma>              Branch if ACC <> 0
BV       <pma>              Branch on overflow
BZ       <pma>              Branch if ACC =  0

CALA                        Call subroutine from ACC
CALL     <pma>              Call subroutine at <pma>

DINT                        Disable interrupt

DMOV     *+,<arp>           Data move in memory
DMOV     *-,<arp>
DMOV     *, <arp>
DMOV     *+
DMOV     *-
DMOV     *
DMOV     <dma>

EINT                        Enable Interrupt

IN       *+,<port> ,<arp>   Input data from port
IN       *-,<port> ,<arp>
IN       * ,<port> ,<arp>
IN       *+,<port>
IN       *-,<port>
IN       * ,<port>
IN       <dma>,<port>

LAC      *+,<shift>,<arp>   Load ACC with shift
LAC      *-,<shift>,<arp>
LAC      *, <shift>,<arp>
LAC      *+,<shift>
LAC      *-,<shift>
LAC      *, <shift>
LAC      *+
LAC      *-
LAC      *
LAC      <dma>,<shift>
LAC      <dma>

LACK     <const8>                   Load ACC with 8 bit constant

LAR      <ar>,*+,<arp>              Load auxiliary Register
TASM TABLES  Version 2.8                                     Page 27

LAR      <ar>,*-,<arp>
LAR      <ar>,*, <arp>
LAR      <ar>,*+
LAR      <ar>,*-
LAR      <ar>,*
LAR      <ar>,<dma>

LARK     <ar>,<const8>              Load aux register with constant
LARP     <const1>                   Load aux register pointer immed

LDP      *+,<arp>                   Load data memory page pointer
LDP      *-,<arp>
LDP      *, <arp>
LDP      *+
LDP      *-
LDP      *
LDP      <dma>

LDPK     <const1>                   Load data page pointer immediate

LST      *+,<arp>                   Load status from data memory
LST      *-,<arp>
LST      *, <arp>
LST      *+
LST      *-
LST      *
LST      <dma>

LT       *+,<arp>                   Load T register
LT       *-,<arp>
LT       *, <arp>
LT       *+
LT       *-
LT       *
LT       <dma>

LTA      *+,<arp>                   Load T register and accumulate
LTA      *-,<arp>                     product
LTA      *, <arp>
LTA      *+
LTA      *-
LTA      *
LTA      <dma>

LTD      *+,<arp>                   Load T reg, accumulate product,
LTD      *-,<arp>                     and move
LTD      *, <arp>
LTD      *+
LTD      *-
LTD      *
LTD      <dma>

MAR      *+,<arp>                   Modify auxiliary register
MAR      *-,<arp>
MAR      *, <arp>
MAR      *+
TASM TABLES  Version 2.8                                     Page 28

MAR      *-
MAR      *
MAR      <dma>

MPY      *+,<arp>                   Multiply
MPY      *-,<arp>
MPY      *, <arp>
MPY      *+
MPY      *-
MPY      *
MPY      <dma>

MPYK     <const13>                  Multiply immediate

NOP                                 No Operation

OR       *+,<arp>                   OR  with low order bits of ACC
OR       *-,<arp>
OR       *, <arp>
OR       *+
OR       *-
OR       *
OR       <dma>

OUT      *+,<port>,<arp>            Output data to port
OUT      *-,<port>,<arp>
OUT      *, <port>,<arp>
OUT      *+,<port>
OUT      *-,<port>
OUT      *, <port>
OUT      <dma>,<port>

PAC                                 Load ACC with P register
POP                                 Pop top of stack to ACC
PUSH                                Push ACC onto stack
RET                                 Return from subroutine
ROVM                                Reset overflow mode register

SACH     *+,<shift>,<arp>           Store ACC high with shift
SACH     *-,<shift>,<arp>             Note: shift can only be 0, 1,
SACH     *, <shift>,<arp>                   or 4
SACH     *+,<shift>
SACH     *-,<shift>
SACH     *, <shift>
SACH     *+
SACH     *-
SACH     *
SACH     <dma>,<shift>
SACH     <dma>

SACL     *+,<arp>                   Store ACC low
SACL     *-,<arp>
SACL     *, <arp>
SACL     *+
SACL     *-
SACL     *
TASM TABLES  Version 2.8                                     Page 29

SACL     <dma>

SAR      <ar>,*+,<arp>              Store auxiliary Register
SAR      <ar>,*-,<arp>
SAR      <ar>,*, <arp>
SAR      <ar>,*+
SAR      <ar>,*-
SAR      <ar>,*
SAR      <ar>,<dma>

SOVM                                Set overflow mode register
SPAC                                Subtract P register from ACC

SST      *+,<arp>                   Store status
SST      *-,<arp>
SST      *, <arp>
SST      *+
SST      *-
SST      *
SST      <dma>

SUB      *+,<shift>,<arp>           Subtract from ACC with shift
SUB      *-,<shift>,<arp>
SUB      *, <shift>,<arp>
SUB      *+,<shift>
SUB      *-,<shift>
SUB      *, <shift>
SUB      *+
SUB      *-
SUB      *
SUB      <dma>,<shift>
SUB      <dma>

SUBC     *+,<arp>                   Conditional subtract
SUBC     *-,<arp>
SUBC     *, <arp>
SUBC     *+
SUBC     *-
SUBC     *
SUBC     <dma>

SUBH     *+,<arp>                   Subtract from high-order ACC
SUBH     *-,<arp>
SUBH     *, <arp>
SUBH     *+
SUBH     *-
SUBH     *
SUBH     <dma>

SUBS     *+,<arp>                   Subtract from low ACC with
SUBS     *-,<arp>                     sign-extension suppressed
SUBS     *, <arp>
SUBS     *+
SUBS     *-
SUBS     *
SUBS     <dma>
TASM TABLES  Version 2.8                                     Page 30

TBLR     *+,<arp>                   Table Read
TBLR     *-,<arp>
TBLR     *, <arp>
TBLR     *+
TBLR     *-
TBLR     *
TBLR     <dma>

TBLW     *+,<arp>                   Table Write
TBLW     *-,<arp>
TBLW     *, <arp>
TBLW     *+
TBLW     *-
TBLW     *
TBLW     <dma>

XOR      *+,<arp>                   Exclusive OR with low bits of ACC
XOR      *-,<arp>
XOR      *, <arp>
XOR      *+
XOR      *-
XOR      *
XOR      <dma>

ZAC                                 Zero the ACC

ZALH     *+,<arp>                   Zero ACC and load high
ZALH     *-,<arp>
ZALH     *, <arp>
ZALH     *+
ZALH     *-
ZALH     *
ZALH     <dma>

ZALS     *+,<arp>                   Zero ACC and load low with
ZALS     *-,<arp>                     sign extension suppressed
ZALS     *, <arp>
ZALS     *+
ZALS     *-
ZALS     *
ZALS     <dma>

See manufacturer's data for more information.

TASM TABLES  Version 2.8                                     Page 31

TMS7000 INSTRUCTIONS AND ADDRESSING MODES

The following list shows the acceptable opcode mnemonics  and  their
corresponding  operand   formats  for the TMS7000  version of  TASM.
The following symbolic fields used in the table:

    SYMBOLIC        DESCRIPTION
    -------------------------------------------
    <iop>           Immediate data (8 bits)
    <Rn>            Register file (memory locations 0 to 127 or
                       0 to 255 depending on on-chip RAM)
    <Pn>            Peripheral file (0-255)
    <rel>           Program address (relative)
    <addr>          Program address (16 bit)
    <trap>          Trap number (0-23)

Any valid TASM expression can appear in the  place  of  any  of  the
above symbolics.

Note  that   TASM  allows   an  alternate   syntax  for   expressing
indirection.  Parenthesis can be  replaced with brackets (which  are
less ambiguous because they do not occur in expressions).  Thus, the
following are equivalent:

    BR      @addr1(B)
    BR      @addr1[B]


OPCODE  OPERANDS
---------------------------------------
ADC    B,A
ADC    %<iop>,A
ADC    %<iop>,B
ADC    %<iop>,<Rn>
ADC    <Rn>,A
ADC    <Rn>,B
ADC    <Rn>,<Rn>

ADD    B,A
ADD    %<iop>,A
ADD    %<iop>,B
ADD    %<iop>,<Rn>
ADD    <Rn>,A
ADD    <Rn>,B
ADD    <Rn>,<Rn>

AND    B,A
AND    %<iop>,A
AND    %<iop>,B
AND    %<iop>,<Rn>
AND    <Rn>,A
AND    <Rn>,B
AND    <Rn>,<Rn>

ANDP   A,<Pn>
ANDP   B,<Pn>
TASM TABLES  Version 2.8                                     Page 32

ANDP   %<iop>,<Pn>

BTJO   B,A,<rel>
BTJO   %<iop>,A,<rel>
BTJO   %<iop>,B,<rel>
BTJO   %<iop>,<Rn>,<rel>
BTJO   <Rn>,A,<rel>
BTJO   <Rn>,B,<rel>
BTJO   <Rn>,<Rn>,<rel>

BTJOP  A,<Pn>,<rel>
BTJOP  B,<Pn>,<rel>
BTJOP  %<iop>,<Pn>,<rel>

BTJZ   B,A,<rel>
BTJZ   %<iop>,A,<rel>
BTJZ   %<iop>,B,<rel>
BTJZ   %<iop>,<Rn>,<rel>
BTJZ   <Rn>,A,<rel>
BTJZ   <Rn>,B,<rel>
BTJZ   <Rn>,<Rn>,<rel>

BTJZP  A,<Pn>,<rel>
BTJZP  B,<Pn>,<rel>
BTJZP  %<iop>,<Pn>,<rel>

BR      @<addr>(B)
BR      @<addr>[B]
BR      @<addr>
BR      *<Rn>

CALL    @<addr>(B)
CALL    @<addr>[B]
CALL    @<addr>
CALL    *<Rn>

CLR     A
CLR     B
CLR     <Rn>
CLRC

CMP     B,A
CMP     %<iop>,A
CMP     %<iop>,B
CMP     %<iop>,<Rn>
CMP     <Rn>,A
CMP     <Rn>,B
CMP     <Rn>,<Rn>

CMPA    @<addr>(B)
CMPA    @<addr>[B]
CMPA    @<addr>
CMPA    *<Rn>

DAC     B,A
DAC     %<iop>,A
TASM TABLES  Version 2.8                                     Page 33

DAC     %<iop>,B
DAC     %<iop>,<Rn>
DAC     <Rn>,A
DAC     <Rn>,B
DAC     <Rn>,<Rn>

DEC     A
DEC     B
DEC     <Rn>

DECD    A
DECD    B
DECD    <Rn>

DINT

DJNZ    A,<rel>
DJNZ    B,<rel>
DJNZ    <Rn>,<rel>

DSB     B,A
DSB     %<iop>,A
DSB     %<iop>,B
DSB     %<iop>,<Rn>
DSB     <Rn>,A
DSB     <Rn>,B
DSB     <Rn>,<Rn>

EINT
IDLE

INC     A
INC     B
INC     <Rn>

INV     A
INV     B
INV     <Rn>

JMP     <rel>

JC      <rel>
JEQ     <rel>
JGE     <rel>
JGT     <rel>
JHS     <rel>
JL      <rel>
JN      <rel>
JNC     <rel>
JNE     <rel>
JNZ     <rel>
JP      <rel>
JPZ     <rel>
JZ      <rel>

LDA     @<addr>(B)
TASM TABLES  Version 2.8                                     Page 34

LDA     @<addr>[B]
LDA     @<addr>
LDA     *<Rn>

LDSP

MOV     A,B
MOV     B,A
MOV     A,<Rn>
MOV     B,<Rn>
MOV     %<iop>,A
MOV     %<iop>,B
MOV     %<iop>,<Rn>
MOV     <Rn>,A
MOV     <Rn>,B
MOV     <Rn>,<Rn>

MOVD    %<iop>[B],<Rn>
MOVD    %<iop>,<Rn>
MOVD    <Rn>,<Rn>

MOVP    A,<Pn>
MOVP    B,<Pn>
MOVP    %<iop>,<Pn>
MOVP    <Pn>,A
MOVP    <Pn>,B

MPY     B,A
MPY     %<iop>,A
MPY     %<iop>,B
MPY     %<iop>,<Rn>
MPY     <Rn>,A
MPY     <Rn>,B
MPY     <Rn>,<Rn>

NOP

OR      B,A
OR      %<iop>,A
OR      %<iop>,B
OR      %<iop>,<Rn>
OR      <Rn>,A
OR      <Rn>,B
OR      <Rn>,<Rn>

ORP     A,<Pn>
ORP     B,<Pn>
ORP     %<iop>,<Pn>

POP     A
POP     B
POP     ST
POP     <Rn>
POPST

PUSH    A
TASM TABLES  Version 2.8                                     Page 35

PUSH    B
PUSH    ST
PUSH    <Rn>
PUSHST

RETI

RETS

RL      A
RL      B
RL      <Rn>

RLC     A
RLC     B
RLC     <Rn>

RR      A
RR      B
RR      <Rn>

RRC     A
RRC     B
RRC     <Rn>

SBB     B,A
SBB     %<iop>,A
SBB     %<iop>,B
SBB     %<iop>,<Rn>
SBB     <Rn>,A
SBB     <Rn>,B
SBB     <Rn>,<Rn>

SETC

STA     @<addr>(B)
STA     @<addr>[B]
STA     @<addr>
STA     *<Rn>

STSP

SUB     B,A
SUB     %<iop>,A
SUB     %<iop>,B
SUB     %<iop>,<Rn>
SUB     <Rn>,A
SUB     <Rn>,B
SUB     <Rn>,<Rn>

SWAP    A
SWAP    B
SWAP    <Rn>

TRAP    <trap>

TASM TABLES  Version 2.8                                     Page 36

TST     A
TSTA
TST     B
TSTB

XCHB    A
XCHB    <Rn>

XOR     B,A
XOR     %<iop>,A
XOR     %<iop>,B
XOR     %<iop>,<Rn>
XOR     <Rn>,A
XOR     <Rn>,B
XOR     <Rn>,<Rn>

XORP    A,<Pn>
XORP    B,<Pn>
XORP    %<iop>,<Pn>

TASM TABLES  Version 2.8                                     Page 37

BUILDING TASM FROM THE SOURCE CODE

TASM  can  be built using the provided 'make'  file,  assuming   the
Microsoft C compiler (version 5.0) is available.  The can be done as
follows:

        make tasm.mak


For UNIX, try this:

        %cc -DUNIX tasm.c macro.c parse.c str.c -o tasm

The header file tasm.h should also be available.

Note  that the UNIX flag is being defined on the command line.  This
causes the following things to happen:

        1.  Tasm.h includes somewhat different system include files
                appropriate for the UNIX environment.

        2.  TASM declares a 64 Kbyte array  in  which  to  hold  the
                assembled    opcodes    and    data  in  a  slightly
                different way.   MS C must use the 'far' keyword for
                such  an  array  to give it a segment  all  its  own
                (assuming use of the small memory model).  Most UNIX
                environments do not have need for such syntax.

TASM TABLES  Version 2.8                                     Page 38

TASM INSTRUCTION SET TABLE DEFINITION

The tables that control TASM's interpretation of the source file are
read from a file at run time.  The table file name is determined  by
taking  the  numeric option field specified on the TASM command line
and appending it to the string "TASM", then a  ".TAB"  extension  is
added.  Thus, if the following command line is entered:

        tasm -51  test.asm

then TASM would read the table file named "TASM51.TAB".


The following rules apply to the structure of the table file:

        1.  The  first  line  of  the  file  should contain a string
                surrounded by double quotes that should identify the
                version of the assembler  table.  This  string  will
                appear at the top of each page in the list file.  It
                should be limited to 24 characters.
        2.  Any line that starts with a '.' is considered a directive.
                The following directives are available:

                DIRECTIVE       MEANING
                ----------------------------------------------------
                MSFIRST         Generate opcodes MS byte first.
                ALTWILD         Use '@' instead of '*' as the
                                wild card in the table.

        3.  Any   line  whose  first  character  is not a '.' and is
                not  alphabetic is considered to be a comment and is
                discarded.

        4.  Any  line  that has an alphabetic character as the first
                character is assumed to be an instruction definition
                record  and  is  parsed  to   build   the   internal
                representation   of   the  instruction  set  tables.
                Eight  fields   (separated  by  white  space)    are
                expected,  as follows:

                Field Name      Description
                --------------------------------------------
                INSTRUCTION     Instruction Mnemonic
                ARGS            Argument definition
                OPCODE          Opcode value
                NBYTES          Number of bytes
                MODOP           Modifier operation
                CLASS           Instruction class
                SHIFT           Argument left shift count
                OR              Argument bitwise OR mask

                INSTRUCTION.  The  INSTRUCTION  field should contain
                the string to be  used  as  the  mnemonic  for  this
                instruction.  Upper case letters should be used (the
                source statements are converted to upper case before
                comparison).
TASM TABLES  Version 2.8                                     Page 39

                ARGS.   The  ARGS  field  should  contain  a  string
                describing  the  format  of  the operand field.  All
                characters are taken literally except the '*'  which
                denotes  the  presence  of  a valid TASM expression.
                Multiple '*'s can be used,  but all but the last one
                must  be  followed  by  a  comma.  If  a  single '*'
                appears in the ARGS field,  then the default  action
                of  TASM  will  be  to  determine  the  value of the
                expression that matches the field and insert one  or
                two  bytes  of  it into the object file depending on
                the NBYTES field.  If multiple '*'s are  used,  then
                special  operators  (MODOP)  must  be  used  to take
                advantage of them (see the examples below).  An ARGS
                field of a pair  of  double  quotes  means  that  no
                arguments are expected.


                OPCODE.  The OPCODE field should contain the  opcode
                value    (two  to  six  hex   digits)   for   this
                instruction  and  address mode.   Each pair  of  hex
                digits  represent  a  single  byte  of  the  opcode,
                ordered with the right most pair being placed in the
                lowest memory location.


                NBYTES.  The NBYTES field should specify the  number
                of  bytes  this  instruction  is to occupy (a single
                decimal  digit).   This number includes both  opcode
                bytes and argument bytes, thus,  the number of bytes
                of argument is computed by subtracting the number of
                bytes  of  opcode  (dictated by the  length  of  the
                OPCODE field) from NBYTES.


                MODOP.  The MODOP field determines  if  any  special
                operations   need   to  be  performed  on  the  code
                generated for this  instruction.  For  example,  the
                zero-page  addressing  mode of the 6502 is a special
                case of the absolute addressing mode, and is handled
                by a special MODOP code (see appendix B).  The  list
                of operators is as follows:


TASM TABLES  Version 2.8                                     Page 40

                MODOP       DESCRIPTION
                ---------------------------------------------------
                NOTOUCH     Do nothing to instruction or args
                JMPPAGE     Put bits 8-10 of first arg into
                            bits 5-7 of opcode (8048 JMP)
                ZPAGE       If arg < 256 then use zero-page (6502)
                R1          Make arg relative to PC (single byte)
                R2          Make arg relative to PC (two byte)
                CREL        Combine LS bytes of first two args
                            making the second one relative to PC
                SWAP        Swap bytes of first arg
                COMBINE     Combine LS bytes of first two args into
                            first arg (arg1 -> LSB, arg2 ->MSB).
                CSWAP       Combine LS bytes of first two args into
                            first arg and swap.
                ZBIT        Z80 bit instructions.
                MBIT        Motorola (6805) bit instructions
                MZERO       Motorola (6805) zero page (direct)
                3ARG        Three args, one byte each.
                3REL        Three args, one byte each, last one
                            relative
                T1          TMS320 instruction with one arg.  Shift
                            according to SHIFT and mask with OR and
                            OR into opcode.  If a second arg exists
                            assume it is an <arp> and OR into   LSB
                            of opcode.
                TDMA        TMS320 instruction with first arg <dma>.
                            Second arg gets shift/and/or  treatment
                            as with T1.
                TAR         TMS320 instruction with first arg <ar>.
                            Second arg gets shift/and/or  treatment
                            as with T1.

                Note  that the reason for the combining of arguments
                (COMBINE and CSWAP) is that TASM  assumes  that  all
                object  bytes  to be inserted in the object file are
                derived from a variable representing  the  value  of
                the  first  argument (argval).  If two arguments are
                in the  ARGS  field,  then  one  of  the  previously
                mentioned  MODOP`s  must  be  used.  They  have  the
                effect of combining the low bytes of the  first  two
                arguments  into the variable (argval) from which the
                object  code  will  be  generated.  TASM`s  argument
                parsing   routine  can  handle  a  large  number  of
                arguments,  but the code that generates  the  object
                code is less capable.

                CLASS.  The  CLASS  field is used to specify whether
                this instruction is part of the standard instruction
                set or a member of a set of  extended  instructions.
                Bit 0 of this field should be set to denote a member
                of  the standard instruction set.  Other bits can be
                used as needed  to  establish  several  classes  (or
                sets)   of  instructions  that  can  be  enabled  or
                disabled via  the  '-x'  command  line  option  (see
                section on 6502 INSTRUCTIONS AND ADDRESSING MODES).
TASM TABLES  Version 2.8                                     Page 41

                SHIFT (optional).   The SHIFT field is used to cause
                the  first  argument of the given instruction to  be
                shifted left the specified number of bits.   (Except
                T1, TDMA, TAR MODOPS as noted below).

                OR  (optional).   The OR field is used to perform  a
                bitwise  OR  with  the first argument of  the  given
                instruction.  Specified as hex digits.  (Except  T1,
                TDMA, TAR MODOPS as noted below).

Note that the SHIFT/OR fields are used somewhat differently for  T1,
TDMA,  and TAR MODOPS.  In those cases,  the SHIFT and OR fields are
used  but the OR field is really an AND mask and the result is  OR'd
with the opcode.

The   following  table   shows   possible    instruction  definition
records,  followed  by  possible  source statements that would match
it,    followed by the resulting object code that would be generated
(in hex):
                                          EXAMPLE         EXAMPLE
INSTRUCTION DEFINITION                    SOURCE          OBJECT
-------------------------------------------------------------------
XYZ  *      FF   3  NOTOUCH 1             xyz 1234h       FF 34 12
XYZ  *      FF   2  NOTOUCH 1             xyz 1234h       FF 34
ZYX  *      FE   3  SWAP    1             zyx 1234h       FE 12 34
ZYX  *      FE   3  R2      1             zyx $+4         FE 01 00
ABC  *,*    FD   3  COMBINE 1             abc 45h,67h     FD 45 67
ABC  *,*    FD   3  CSWAP   1             abc 45h,67h     FD 67 45
ADD  A,#*   FC   2  NOTOUCH 1             add A,#'B'      FC 42
RET  ""     FB   1  NOTOUCH 1             ret             FB
LD   IX,*   21DD 4  NOTOUCH 1             ld  IX,1234h    DD 21 34 12
LD   IX,*   21DD 4  NOTOUCH 1 1 0         ld  IX,1234h    DD 21 68 24
LD   IX,*   21DD 4  NOTOUCH 1 0 1         ld  IX,1234h    DD 21 35 12
LD   IX,*   21DD 4  NOTOUCH 1 1 1         ld  IX,1234h    DD 21 69 24
LD   IX,*   21DD 4  NOTOUCH 1 8 12        ld  IX,34h      DD 21 12 34

The  order  of  the  entries for various addressing modes of a given
instruction is important.  Since the wild card matches anything,  it
is  important to specify the ARGS for the addressing modes that have
the  most  qualifying  characters  first.   For   example,   if   an
instruction  had  two  addressing  modes,   one  that  accepted  any
expression,  and another that required a pound sign in front  of  an
expression,  the  pound  sign  entry  should  go first otherwise all
occurrences of the instruction would match  the  more  general  ARGS
expression   that  it  encountered  first.   The  following  entries
illustrate the proper sequencing:

        ADD #*  12 3 NOTOUCH 1
        ADD *   13 3 NOTOUCH 1

